#!/usr/bin/env python
"""
Generate TypeScript type definitions from Pydantic schemas.

This script extracts JSON schemas from our Pydantic models (which extend adcp library schemas)
and generates TypeScript definitions. This ensures frontend types match backend schemas exactly.

Usage:
    uv run python scripts/generate_frontend_types.py

Output:
    static/js/generated-types.d.ts
"""

from pathlib import Path

# Import our Pydantic schemas (which extend adcp library)
from src.core.schemas import (
    Creative,
    Format,
    FormatId,
    Package,
    Product,
    Property,
)


def pydantic_to_typescript(schema: dict, type_name: str) -> str:
    """
    Convert Pydantic JSON schema to TypeScript interface.

    This is a simple converter. For production, consider using:
    - json-schema-to-typescript npm package
    - openapi-typescript
    - quicktype
    """
    lines = [f"export interface {type_name} {{"]

    properties = schema.get("properties", {})
    required = set(schema.get("required", []))

    for prop_name, prop_schema in properties.items():
        # Determine if optional
        optional_marker = "" if prop_name in required else "?"

        # Get TypeScript type
        ts_type = json_schema_to_ts_type(prop_schema)

        # Get description
        description = prop_schema.get("description", "")
        if description:
            lines.append(f"  /** {description} */")

        lines.append(f"  {prop_name}{optional_marker}: {ts_type};")

    lines.append("}")
    return "\n".join(lines)


def json_schema_to_ts_type(schema: dict) -> str:
    """Convert JSON schema type to TypeScript type."""

    # Handle anyOf (union types)
    if "anyOf" in schema:
        types = [json_schema_to_ts_type(s) for s in schema["anyOf"]]
        return " | ".join(types)

    # Handle $ref (reference to another type)
    if "$ref" in schema:
        ref = schema["$ref"]
        # Extract type name from #/$defs/TypeName
        type_name = ref.split("/")[-1]
        return type_name

    # Handle array
    if schema.get("type") == "array":
        items = schema.get("items", {})
        item_type = json_schema_to_ts_type(items)
        return f"{item_type}[]"

    # Handle object
    if schema.get("type") == "object":
        # Check for additionalProperties
        if schema.get("additionalProperties"):
            return "Record<string, any>"
        return "object"

    # Simple types
    type_map = {
        "string": "string",
        "integer": "number",
        "number": "number",
        "boolean": "boolean",
        "null": "null",
    }

    schema_type = schema.get("type")
    return type_map.get(schema_type, "any")


def generate_types():
    """Generate TypeScript types from Pydantic models."""

    output = [
        "/**",
        " * AUTO-GENERATED TypeScript definitions from backend Pydantic schemas",
        " *",
        " * DO NOT EDIT THIS FILE MANUALLY!",
        " * Generated by: scripts/generate_frontend_types.py",
        " *",
        " * These types match the JSON structure returned by backend APIs.",
        " * They are derived from Pydantic models which extend the adcp library schemas.",
        " *",
        " * To regenerate: uv run python scripts/generate_frontend_types.py",
        " */",
        "",
    ]

    # Generate types for key models
    models = {
        "Format": Format,
        "FormatId": FormatId,
        "Product": Product,
        "Package": Package,
        "Property": Property,
        "Creative": Creative,
    }

    for name, model in models.items():
        schema = model.model_json_schema()

        # Process $defs (nested type definitions)
        if "$defs" in schema:
            for def_name, def_schema in schema["$defs"].items():
                output.append(pydantic_to_typescript(def_schema, def_name))
                output.append("")

        # Process main type
        output.append(pydantic_to_typescript(schema, name))
        output.append("")

    # Write to file
    output_path = Path(__file__).parent.parent / "static" / "js" / "generated-types.d.ts"
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w") as f:
        f.write("\n".join(output))

    print(f"âœ… Generated TypeScript types: {output_path}")
    print(f"   Types generated: {', '.join(models.keys())}")


if __name__ == "__main__":
    generate_types()
