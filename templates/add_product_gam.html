{% extends "base.html" %}

{% block title %}{{ 'Edit' if product else 'Create' }} Product - Google Ad Manager{% endblock %}

{% block content %}
<div class="card">
    <div class="back-button-container">
        <a href="{{ url_for('products.list_products', tenant_id=tenant_id) }}" class="btn btn-secondary btn-back">
            ‚Üê Back to Products
        </a>
    </div>

    <h2>{{ 'Edit' if product else 'Create' }} Product (Google Ad Manager)</h2>

    {% if not inventory_synced %}
    <div class="alert alert-warning" style="margin-bottom: 2rem; padding: 1rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
        <h4 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Inventory Not Synced</h4>
        <p style="margin-bottom: 1rem;">GAM inventory has not been synced yet. You won't be able to select ad units or placements until inventory is synced.</p>
        <a href="{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}" class="btn btn-primary">
            üìä Go to Inventory Browser to Sync
        </a>
    </div>
    {% endif %}

    <form id="product-form" method="POST" onsubmit="prepareFormSubmission(event)">
        <!-- Section 1: Product Basics -->
        <h3 style="margin-top: 0; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Product Information</h3>
        <p style="color: #666; margin-bottom: 1.5rem;">Basic product details that buyers will see</p>

        <div class="form-group">
            <label for="name">Product Name *</label>
            <input type="text" id="name" name="name" required placeholder="e.g., Premium Homepage Package" value="{{ form_data.name if form_data else (product.name if product else '') }}">
            <small style="color: #666;" id="name-product-note" style="display: none;">
                For dynamic products, this is the base product name. Variants will use your name template pattern.
            </small>
        </div>

        <div class="form-group">
            <label for="description">Description</label>
            <textarea id="description" name="description" rows="3" placeholder="Describe this product for potential buyers">{{ form_data.description if form_data else (product.description if product else '') }}</textarea>
            <small style="color: #666;" id="description-product-note" style="display: none;">
                For dynamic products, this is the base product description. Variants will use your description template pattern.
            </small>
        </div>

        <!-- Section 2: Dynamic Products Configuration -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">
            <i class="fas fa-lightning-bolt"></i> Dynamic Products (Signals-Based)
        </h3>
        <div class="alert" style="background: #d1ecf1; border-left: 4px solid #17a2b8; padding: 1rem; margin-bottom: 1rem;">
            <strong>Optional:</strong> Make this product dynamic to automatically generate variants from signals agents based on buyer briefs.
        </div>

        <div class="form-group">
            <label style="display: inline-block; cursor: pointer;">
                <input type="checkbox" id="is_dynamic" name="is_dynamic"
                       {% if form_data and form_data.is_dynamic %}checked{% elif product and product.is_dynamic %}checked{% endif %}
                       {% if not signals_agents or signals_agents|length == 0 %}disabled{% endif %}
                       style="margin-right: 0.5rem; vertical-align: middle;">
                <span style="vertical-align: middle;">This is a dynamic product</span>
            </label>
            {% if not signals_agents or signals_agents|length == 0 %}
            <div style="color: #dc3545; font-size: 0.9rem; margin-left: 1.75rem; margin-top: 0.25rem;">
                (Disabled - <a href="{{ url_for('signals_agents.list_signals_agents', tenant_id=tenant_id) }}">Add a signals agent first</a>)
            </div>
            {% endif %}
            <small style="color: #666; display: block; margin-top: 0.5rem;">
                When enabled, this product acts as a base. The system will query signals agents and create product variants with targeting based on active signals.
            </small>
        </div>

        <div id="dynamic-product-config" style="display: {% if product and product.is_dynamic %}block{% else %}none{% endif %}; margin-left: 1.5rem; padding: 1rem; background: #f8f9fa; border-radius: 4px; margin-top: 1rem; margin-bottom: 2rem;">
            <h4 style="margin-top: 0;">Dynamic Product Settings</h4>

            <!-- Signals Agent Selection -->
            <div class="form-group">
                <label><strong>Signals Agents</strong></label>

                {% set selected_agents = product.signals_agent_ids if product and product.signals_agent_ids else [] %}
                {% set use_all_agents = not product or not product.signals_agent_ids or product.signals_agent_ids|length == 0 %}

                <div style="margin-left: 1rem; margin-top: 0.5rem;">
                    <label style="display: block; margin-bottom: 1rem; cursor: pointer;">
                        <input type="radio" name="signals_agent_selection" value="all"
                               {% if use_all_agents %}checked{% endif %}
                               style="margin-right: 0.5rem;">
                        <strong>All Agents</strong> <span style="color: #28a745;">(Recommended)</span>
                        <div style="margin-left: 1.75rem; color: #666; font-size: 0.9rem; margin-top: 0.25rem;">
                            Automatically query all configured signals agents. When you add or change agents, products will automatically use them without modification.
                        </div>
                    </label>

                    <label style="display: block; margin-bottom: 0.5rem; cursor: pointer;">
                        <input type="radio" name="signals_agent_selection" value="specific"
                               {% if not use_all_agents %}checked{% endif %}
                               style="margin-right: 0.5rem;">
                        <strong>Specific Agents</strong> <span style="color: #666;">(Advanced)</span>
                    </label>

                    <div id="specific-agents-selection" style="display: {% if not use_all_agents %}block{% else %}none{% endif %}; margin-left: 1.75rem; margin-top: 0.5rem;">
                        <select name="signals_agent_ids" id="signals_agent_ids" multiple size="5" style="width: 100%;">
                            {% if signals_agents %}
                                {% for agent in signals_agents %}
                                <option value="{{ agent.agent_id }}"
                                        {% if agent.agent_id in selected_agents %}selected{% endif %}>
                                    {{ agent.name }} - {{ agent.agent_url }}
                                </option>
                                {% endfor %}
                            {% else %}
                                <option disabled>No signals agents configured</option>
                            {% endif %}
                        </select>
                        <small style="color: #666; display: block; margin-top: 0.25rem;">
                            Select one or more signals agents to query. System will create product variants based on signals returned for buyer's brief.
                            {% if not signals_agents %}
                            <br><a href="{{ url_for('signals_agents.list_signals_agents', tenant_id=tenant_id) }}">Configure signals agents first</a>
                            {% endif %}
                        </small>
                    </div>
                </div>
            </div>

            <!-- Variant Naming Pattern -->
            <div class="form-group">
                <label><strong>Variant Naming Pattern</strong></label>

                <div style="margin-left: 1rem; margin-top: 0.5rem;">
                    <label style="display: block; margin-bottom: 1rem; cursor: pointer;">
                        <input type="radio" name="variant_name_pattern" value="default"
                               {% if not product or not product.variant_name_template %}checked{% endif %}
                               style="margin-right: 0.5rem;">
                        <strong>Product Name - Signal Name</strong> <span style="color: #28a745;">(Recommended)</span>
                        <div style="margin-left: 1.75rem; color: #666; font-size: 0.9rem; margin-top: 0.25rem;">
                            Example: "Run of Site - Weather Targeting"
                        </div>
                    </label>

                    <label style="display: block; margin-bottom: 1rem; cursor: pointer;">
                        <input type="radio" name="variant_name_pattern" value="signal_only"
                               {% if product and product.variant_name_template == "{{ '{{signal.name}}' }}" %}checked{% endif %}
                               style="margin-right: 0.5rem;">
                        <strong>Signal Name Only</strong>
                        <div style="margin-left: 1.75rem; color: #666; font-size: 0.9rem; margin-top: 0.25rem;">
                            Example: "Weather Targeting"
                        </div>
                    </label>

                    <label style="display: block; margin-bottom: 0.5rem; cursor: pointer;">
                        <input type="radio" name="variant_name_pattern" value="custom"
                               {% if product and product.variant_name_template and product.variant_name_template != "{{ '{{signal.name}}' }}" %}checked{% endif %}
                               style="margin-right: 0.5rem;">
                        <strong>Custom Pattern</strong> <span style="color: #666;">(Advanced)</span>
                    </label>

                    <div id="custom-name-pattern" style="display: {% if product and product.variant_name_template and product.variant_name_template != '{{signal.name}}' %}block{% else %}none{% endif %}; margin-left: 1.75rem; margin-top: 0.5rem; margin-bottom: 0.5rem;">
                        <input type="text" id="variant_name_template" name="variant_name_template"
                               value="{{ form_data.variant_name_template if form_data else (product.variant_name_template if product and product.variant_name_template else '') }}"
                               placeholder="{{ '{{name}}' }} - {{ '{{signal.name}}' }}" style="width: 100%;">
                        <small style="color: #666; display: block; margin-top: 0.25rem;">
                            Available: <code>{{ '{{name}}' }}</code>, <code>{{ '{{signal.name}}' }}</code>,
                            <code>{{ '{{activation_key.key}}' }}</code>, <code>{{ '{{activation_key.value}}' }}</code>
                        </small>
                    </div>
                </div>
            </div>

            <!-- Variant Description -->
            <div class="form-group">
                <label>
                    <input type="checkbox" name="append_signal_description" id="append_signal_description"
                           {% if not product or product.variant_description_template is none or product.variant_description_template == '' %}checked{% endif %}
                           style="margin-right: 0.5rem;">
                    <strong>Append signal targeting description</strong>
                </label>
                <small style="display: block; margin-left: 1.75rem; color: #666; margin-top: 0.25rem;">
                    Adds the targeting details to help buyers understand what makes this variant unique
                </small>

                <div id="signal-description-preview" style="{% if not product or product.variant_description_template is none or product.variant_description_template == '' %}display: block;{% else %}display: none;{% endif %} margin-left: 1.75rem; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #007bff;">
                    <strong style="font-size: 0.9rem; color: #495057;">Preview:</strong>
                    <div style="margin-top: 0.5rem; color: #666; font-size: 0.9rem; white-space: pre-line;">Run of Site inventory with premium placement.

Target users based on local weather conditions for maximum relevance.</div>
                </div>
            </div>

            <!-- Max Signals -->
            <div class="form-group">
                <label for="max_signals">Maximum Variants</label>
                <input type="number" id="max_signals" name="max_signals"
                       value="{{ form_data.max_signals if form_data else (product.max_signals if product and product.max_signals else 5) }}"
                       min="1" max="20" style="width: 150px;">
                <small style="color: #666;">Maximum number of product variants to create from signals (default: 5)</small>
            </div>

            <!-- Variant TTL -->
            <div class="form-group">
                <label for="variant_ttl_days">Variant Expiration (Days)</label>
                <input type="number" id="variant_ttl_days" name="variant_ttl_days"
                       value="{{ form_data.variant_ttl_days if form_data else (product.variant_ttl_days if product and product.variant_ttl_days else '') }}"
                       min="1" max="365" placeholder="30" style="width: 150px;">
                <small style="color: #666;">How many days until unused variants expire (leave blank for tenant default of 30 days)</small>
            </div>

            <div class="alert" style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem; margin-top: 1rem;">
                <strong>How Dynamic Products Work:</strong>
                <ul style="margin: 0.5rem 0 0 0; padding-left: 1.5rem;">
                    <li>This product serves as a base with all settings (formats, pricing, targeting)</li>
                    <li>When buyers call get_products with a brief, we query your selected signals agents</li>
                    <li>For each matching signal (up to max variants), we create a product variant</li>
                    <li>Variants inherit all base product settings and include signal-based targeting</li>
                    <li>Variant names and descriptions are generated using your templates (or defaults)</li>
                    <li>Variants are single-use and expire after the configured TTL</li>
                    <li>Buyers see variants as normal products - the implementation is transparent</li>
                </ul>
            </div>
        </div>

        <!-- Channel & Geographic Targeting -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Channel & Geographic Targeting</h3>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div class="form-group">
                <label for="channels">Advertising Channels</label>
                {% set selected_channels = product.channels if product and product.channels else [] %}
                {% include 'components/channel_selector.html' %}
            </div>

            <div class="form-group">
                <label for="countries">Countries</label>
                {% set selected_countries = product.countries if product and product.countries else [] %}
                {% include 'components/country_selector.html' %}
            </div>
        </div>

        <!-- Publisher Properties -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Publisher Properties (AdCP)</h3>
        <div class="alert" style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem; margin-bottom: 1rem;">
            <strong>Required:</strong> Specify which properties this product covers so buyers can validate against their authorized properties.
        </div>

        {% include 'components/publisher_properties_selector.html' %}

        <!-- Principal Access Control -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Principal Access Control</h3>
        <p style="color: #666; margin-bottom: 1rem;">
            Restrict which advertisers/principals can see this product. Leave empty to show to all principals.
        </p>

        <div class="form-group">
            <label for="allowed_principal_ids">Allowed Principals (Advertisers)</label>
            {% set selected_principals = product.allowed_principal_ids if product and product.allowed_principal_ids else [] %}
            <select id="allowed_principal_ids" name="allowed_principal_ids" multiple style="height: 120px;">
                {% if principals %}
                    {% for principal in principals %}
                    <option value="{{ principal.principal_id }}"
                            {% if principal.principal_id in selected_principals %}selected{% endif %}>
                        {{ principal.name }} ({{ principal.principal_id }})
                    </option>
                    {% endfor %}
                {% else %}
                    <option disabled>No principals configured</option>
                {% endif %}
            </select>
            <small style="color: #666;">
                Hold Ctrl/Cmd to select multiple. If none selected, product is visible to all principals.
            </small>
        </div>

        <!-- Section 2: Inventory Configuration -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Inventory Configuration *</h3>
        <p style="color: #666; margin-bottom: 1rem;">
            <strong>Choose one:</strong> Use an inventory profile (recommended) or configure inventory manually below
        </p>

        <div class="form-group" style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 1rem;">
            <select name="inventory_profile_id" id="inventory_profile_id" onchange="handleProfileChange(this.value)" style="flex: 1; padding: 0.75rem; border: 2px solid #ddd; border-radius: 4px; font-size: 1rem;">
                <option value="">-- Or Configure Manually Below --</option>
                {% if inventory_profiles %}
                    {% for profile in inventory_profiles %}
                    <option value="{{ profile.id }}"
                            data-description="{{ profile.description or '' }}"
                            data-format-count="{{ profile.format_count or 0 }}"
                            {% if (form_data and form_data.inventory_profile_id|string == profile.id|string) or (product and product.inventory_profile_id == profile.id) %}selected{% endif %}>
                        {{ profile.name }}
                    </option>
                    {% endfor %}
                {% endif %}
            </select>
            <button type="button" class="btn btn-primary" onclick="openInventoryProfileCreator()" style="white-space: nowrap;">
                <i class="fas fa-plus"></i> Create New
            </button>
        </div>

        <!-- Profile preview (shown when profile selected) -->
        <div id="inventory-profile-preview" style="display: {% if (form_data and form_data.inventory_profile_id) or (product and product.inventory_profile_id) %}block{% else %}none{% endif %}; padding: 1rem; background: #f0f7ff; border: 2px solid #d0e7ff; border-radius: 6px; margin-bottom: 1rem;">
            <div style="display: flex; justify-content: space-between; align-items: start;">
                <div style="flex: 1;">
                    <strong style="color: #1976d2; display: block; margin-bottom: 0.5rem;">Selected Profile:</strong>
                    <div id="profile-preview-name" style="font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem;"></div>
                    <div id="profile-preview-description" style="color: #666; font-size: 0.9rem; margin-bottom: 0.75rem;"></div>
                    <div id="profile-preview-details" style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.85rem; color: #555;">
                        <!-- Populated by JS -->
                    </div>
                </div>
                <a href="#" id="profile-preview-edit-link" target="_blank" style="white-space: nowrap; font-size: 0.9rem;">
                    Edit Profile ‚Üí
                </a>
            </div>
        </div>

        <div id="manual-inventory-section" style="display: {% if (form_data and form_data.inventory_profile_id) or (product and product.inventory_profile_id) %}none{% else %}block{% endif %};">
            <!-- Manual Inventory Selection -->
            <h4 style="margin-top: 1.5rem; color: #666;">GAM Inventory</h4>
            <p style="color: #666; margin-bottom: 1rem;">Select ad units and placements from your GAM inventory</p>

            <div class="form-group">
                <label for="ad-unit-search">Ad Units</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                <input type="text" id="ad-unit-search" placeholder="Search ad units..." style="flex: 1;">
                <button type="button" onclick="window.inventoryPicker.open('ad_unit')" class="btn btn-secondary" {% if not inventory_synced %}disabled{% endif %}>
                    Browse Ad Units
                </button>
            </div>
            <div id="selected-ad-units" style="min-height: 60px; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f9f9f9;">
                <span style="color: #999;">No ad units selected</span>
            </div>
            <textarea id="targeted_ad_unit_ids" name="targeted_ad_unit_ids" style="display: none;"></textarea>
        </div>

        <div class="form-group">
            <label for="placement-search">Placements</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                <input type="text" id="placement-search" placeholder="Search placements..." style="flex: 1;">
                <button type="button" onclick="window.inventoryPicker.open('placement')" class="btn btn-secondary" {% if not inventory_synced %}disabled{% endif %}>
                    Browse Placements
                </button>
            </div>
            <div id="selected-placements" style="min-height: 60px; border: 1px solid #ddd; border-radius: 4px; padding: 0.5rem; background: #f9f9f9;">
                <span style="color: #999;">No placements selected</span>
            </div>
            <textarea id="targeted_placement_ids" name="targeted_placement_ids" style="display: none;"></textarea>
        </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" name="include_descendants" checked>
                    Include child ad units in targeting
                </label>
            </div>
        </div><!-- end manual-inventory-section -->

        <!-- Section 3: Creative Formats (only shown in custom mode) -->
        <div id="creative-formats-section" style="display: {% if (form_data and form_data.inventory_profile_id) or (product and product.inventory_profile_id) %}none{% else %}block{% endif %};">
            <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Creative Formats</h3>
            <p style="color: #666; margin-bottom: 1rem;">
                Select format templates and configure sizes. Creative type (image, JS, HTML5) is auto-detected when advertisers upload creatives.
                <br><small>Note: Audio formats are not supported by Google Ad Manager.</small>
            </p>

            <!-- Format Template Picker Container -->
            <div id="format-template-picker-container">
                <div style="text-align: center; padding: 2rem; color: #666;">
                    Loading format templates...
                </div>
            </div>

            <!-- Hidden input for formats JSON (populated by picker) -->
            <input type="hidden" id="formats-data" name="formats" value="[]">
        </div><!-- end creative-formats-section -->

        <!-- Load Format Template Picker JS -->
        <script src="{{ request.script_root }}/static/js/format-template-picker.js"></script>

        <!-- Section 4: Pricing Options (AdCP PR #88) -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">Pricing Options</h3>

        <div style="margin-top: 1.5rem; padding: 1rem; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
            <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">Add one or more pricing models for this product. Buyers can choose which model to use.</p>

            <div id="pricing-options-container">
                <!-- Pricing options will be added here by JavaScript -->
            </div>

            <button type="button" class="btn btn-secondary" onclick="addPricingOption()" style="margin-top: 0.5rem;">
                + Add Pricing Option
            </button>
        </div>

        <!-- Section 5: GAM Line Item Configuration -->
        <h3 style="margin-top: 2rem; border-bottom: 2px solid #007bff; padding-bottom: 0.5rem;">GAM Line Item Configuration</h3>

        <div style="padding: 1rem; background: #e7f3ff; border-left: 4px solid #007bff; border-radius: 4px;">
            <strong>‚ÑπÔ∏è Automatic Configuration</strong>
            <p style="margin: 0.5rem 0 0 0; color: #666; font-size: 0.9rem;">
                Line item type and priority are automatically determined based on your selected pricing model:
            </p>
            <ul style="margin: 0.5rem 0 0 1.5rem; color: #666; font-size: 0.9rem;">
                <li><strong>CPM Fixed</strong> ‚Üí Standard line item (priority 8, guaranteed delivery)</li>
                <li><strong>Flat Rate</strong> ‚Üí Sponsorship line item (priority 4, guaranteed delivery)</li>
                <li><strong>CPM/VCPM/CPC Auction</strong> ‚Üí Price Priority line item (priority 12, non-guaranteed)</li>
            </ul>
        </div>

        <!-- ============================================================
             CUSTOM TARGETING (Key-Value Pairs) - WHO SEES THE ADS

             This section configures audience targeting using custom key-value pairs
             from GAM (e.g., "sport=basketball", "genre=action", "age=18-34").

             This is SEPARATE from inventory targeting (which ad units/placements).

             Example: If you want ads to only show to sports fans watching basketball,
             you'd use custom targeting here: sport=basketball
             ============================================================ -->
        <h3 style="margin-top: 2rem;">üéØ Custom Targeting (Optional)</h3>
        <div class="alert" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem;">
            <strong>üí° Who Sees This:</strong> Configure custom targeting (key-value pairs) to define which audience segments will see ads for this product.
            <br><small style="color: #666;">Example: sport=basketball, genre=action, age=18-34</small>
        </div>

        {# Enhanced targeting selector with OR/AND operators and include/exclude #}
        {% include 'components/targeting_selector_widget.html' %}
        <input type="hidden" id="targeting-data" name="targeting_template" value='{{ (form_data.targeting_template | e) if form_data and form_data.targeting_template else (product.targeting_template | tojson if product and product.targeting_template else "{}") }}'>

        <!-- Product Details (AdCP Compliance) -->
        <h3 style="margin-top: 2rem;">
            <i class="fas fa-info-circle"></i> Product Details
        </h3>
        <div class="alert" style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem; margin-bottom: 1rem;">
            <strong>Required:</strong> Delivery measurement is required per AdCP spec. Other details enhance product visibility for buyers.
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div class="form-group">
                <label for="delivery_measurement_provider">Delivery Measurement Provider *</label>
                {% set measurement_config = tenant.measurement_providers if tenant else {} %}
                {% set providers = measurement_config.providers if measurement_config else [] %}
                {% set default_provider = measurement_config.default if measurement_config else '' %}
                {% set current_value = product.delivery_measurement.provider if product and product.delivery_measurement else default_provider %}

                <input type="text" id="delivery_measurement_provider" name="delivery_measurement_provider"
                       list="measurement_providers_list"
                       placeholder="e.g., Google Ad Manager with IAS viewability"
                       value="{{ form_data.delivery_measurement_provider if form_data else current_value }}" required>
                <datalist id="measurement_providers_list">
                    {% if providers %}
                        {% for provider in providers %}
                        <option value="{{ provider }}">
                        {% endfor %}
                    {% else %}
                        <option value="Google Ad Manager">
                        <option value="Google Ad Manager with IAS">
                        <option value="Google Ad Manager with MOAT">
                    {% endif %}
                </datalist>
                <small style="color: #666;">Select from configured providers or enter custom (autocomplete enabled)</small>
            </div>

            <div class="form-group">
                <label for="delivery_measurement_notes">Measurement Notes</label>
                <input type="text" id="delivery_measurement_notes" name="delivery_measurement_notes"
                       value="{{ form_data.delivery_measurement_notes if form_data else (product.delivery_measurement.notes if product and product.delivery_measurement else '') }}"
                       placeholder="e.g., MRC-accredited viewability. 50% in-view for 1s">
                <small style="color: #666;">Additional methodology details (optional)</small>
            </div>
        </div>

        <div class="form-group">
            <label for="product_image_url">Product Image URL (Optional)</label>
            <input type="url" id="product_image_url" name="product_image_url"
                   placeholder="https://example.com/product-image.jpg"
                   value="{{ product.product_card.manifest.product_image if product and product.product_card and product.product_card.manifest else '' }}">
            <small style="color: #666;">
                Product image for visual cards (300x400px recommended). Leave blank to auto-generate from product data.
            </small>
            {% if product and product.product_card and product.product_card.manifest and product.product_card.manifest.product_image %}
            <div style="margin-top: 0.5rem;">
                <img src="{{ product.product_card.manifest.product_image }}" alt="Current product image" style="max-width: 200px; border: 1px solid #ddd; border-radius: 4px;">
            </div>
            {% endif %}
        </div>

        <!-- Submit Buttons -->
        <div style="margin-top: 2rem; display: flex; gap: 1rem;">
            <button type="submit" class="btn btn-primary">{{ 'Update Product' if product else 'Create Product' }}</button>
            <a href="{{ url_for('products.list_products', tenant_id=tenant_id) }}" class="btn btn-secondary">Cancel</a>
        </div>
    </form>
</div>

<script>
// Show/hide dynamic product configuration and product notes
document.getElementById('is_dynamic').addEventListener('change', function(e) {
    const isDynamic = e.target.checked;
    document.getElementById('dynamic-product-config').style.display = isDynamic ? 'block' : 'none';

    // Show/hide product notes for name and description fields
    const nameNote = document.getElementById('name-product-note');
    const descNote = document.getElementById('description-product-note');
    if (nameNote) nameNote.style.display = isDynamic ? 'block' : 'none';
    if (descNote) descNote.style.display = isDynamic ? 'block' : 'none';
});

// Initialize on page load if editing dynamic product
if (document.getElementById('is_dynamic').checked) {
    const nameNote = document.getElementById('name-product-note');
    const descNote = document.getElementById('description-product-note');
    if (nameNote) nameNote.style.display = 'block';
    if (descNote) descNote.style.display = 'block';
}

// Handle signals agent selection radio buttons
document.querySelectorAll('input[name="signals_agent_selection"]').forEach(function(radio) {
    radio.addEventListener('change', function() {
        const specificAgents = document.getElementById('specific-agents-selection');
        if (this.value === 'specific') {
            specificAgents.style.display = 'block';
        } else {
            specificAgents.style.display = 'none';
        }
    });
});

// Handle variant naming pattern radio buttons
document.querySelectorAll('input[name="variant_name_pattern"]').forEach(function(radio) {
    radio.addEventListener('change', function() {
        const customPattern = document.getElementById('custom-name-pattern');
        if (this.value === 'custom') {
            customPattern.style.display = 'block';
        } else {
            customPattern.style.display = 'none';
        }
    });
});

// Handle append signal description checkbox
const appendCheckbox = document.getElementById('append_signal_description');
if (appendCheckbox) {
    appendCheckbox.addEventListener('change', function() {
        const preview = document.getElementById('signal-description-preview');
        if (preview) {
            preview.style.display = this.checked ? 'block' : 'none';
        }
    });
}
</script>

<!-- Include shared hierarchical tree view styles -->
{% include 'partials/hierarchical_tree_styles.html' %}

<style>
.format-card input[type="checkbox"]:checked + strong {
    color: #007bff;
}

.format-card:has(input[type="checkbox"]:checked) {
    border-color: #007bff;
    background-color: #e7f3ff;
}

.format-card:hover {
    border-color: #007bff;
    background-color: #f8f9fa;
}

/* Product-specific inventory container styling */
#inventory-list {
    font-size: 14px;
    line-height: 1.5;
}

/* Product-specific checkbox class alias */
.ad-unit-checkbox {
    margin: 0 8px 0 0;
    cursor: pointer;
    flex-shrink: 0;
    width: 16px;
    height: 16px;
}
</style>

<script>
// Wait for inventory picker to be initialized before accessing it
let inventoryCache = null;

// ============================================================================
// Creative Format Size Filtering Functions (Forward Declaration)
// ============================================================================

/**
 * Helper function to add sizes to inventory cache
 * Eliminates duplicate size extraction code
 * @param {Array} sizes - Array of size objects with width and height properties
 */
function addSizesToCache(sizes) {
    if (!sizes || !Array.isArray(sizes)) return;

    sizes.forEach(size => {
        const sizeKey = `${size.width}x${size.height}`;
        inventoryCache.extractedSizes.add(sizeKey);
        inventoryCache.sizeUnitCounts.set(
            sizeKey,
            (inventoryCache.sizeUnitCounts.get(sizeKey) || 0) + 1
        );
    });
}

/**
 * Extract all sizes from selected ad units and placements
 * Note: Defined early so it's available in DOMContentLoaded handler
 */
async function extractSizesFromInventory() {
    // Safety check - inventory picker must be initialized
    if (!inventoryCache) {
        console.warn('Inventory picker not initialized yet');
        return;
    }

    // Clear previous sizes
    inventoryCache.extractedSizes.clear();
    inventoryCache.sizeUnitCounts.clear();

    // Get selected ad unit and placement IDs
    const adUnitIds = (document.getElementById('targeted_ad_unit_ids').value || '').split(',').filter(Boolean);
    const placementIds = (document.getElementById('targeted_placement_ids').value || '').split(',').filter(Boolean);

    // Helper function to recursively extract sizes from an ad unit and its children
    const extractSizesFromUnit = (unitId) => {
        const item = inventoryCache.adUnits.get(unitId);
        if (!item) return;

        // Extract sizes from this unit using helper function
        // Check both item.sizes (raw API format) and item.metadata.sizes (normalized format)
        const unitSizes = item.sizes || (item.metadata && item.metadata.sizes) || [];
        if (unitSizes.length > 0) {
            addSizesToCache(unitSizes);
        }

        // Recursively extract sizes from children (for hierarchical ad units)
        // Children are stored as full objects from the tree API
        if (item.children && Array.isArray(item.children)) {
            item.children.forEach(child => {
                // Child has sizes directly from tree API - use helper function
                addSizesToCache(child.sizes);
                // Recursively process grandchildren if they exist
                if (child.children && Array.isArray(child.children)) {
                    // Cache this child so we can process its children recursively
                    if (!inventoryCache.adUnits.has(child.id)) {
                        inventoryCache.adUnits.set(child.id, {
                            id: child.id,
                            name: child.name,
                            path: child.path,
                            metadata: { sizes: child.sizes || [] },
                            children: child.children || []
                        });
                    }
                    extractSizesFromUnit(child.id);
                }
            });
        }
    };

    // Extract sizes from ad units directly (including their children)
    adUnitIds.forEach(id => {
        extractSizesFromUnit(id);
    });

    // For placements, need to lookup their ad units and get sizes
    // First, collect which ad units need fetching
    const missingAdUnitIds = new Set();
    for (const placementId of placementIds) {
        const placement = inventoryCache.placements.get(placementId);
        if (placement && placement.metadata && placement.metadata.ad_unit_ids) {
            for (const adUnitId of placement.metadata.ad_unit_ids) {
                if (!inventoryCache.adUnits.has(adUnitId)) {
                    missingAdUnitIds.add(adUnitId);
                }
            }
        }
    }

    // Fetch specific missing ad units by ID (bypasses 500-item limit)
    if (missingAdUnitIds.size > 0) {
        try {
            const idsParam = Array.from(missingAdUnitIds).join(',');
            console.log(`[DEBUG] Fetching ${missingAdUnitIds.size} missing ad units for placement size extraction`);
            const response = await fetch(
                `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit&ids=${encodeURIComponent(idsParam)}`
            );
            const data = await response.json();
            console.log(`[DEBUG] Received ${data.items.length} ad units for size extraction`);
            data.items.forEach(item => {
                inventoryCache.adUnits.set(item.id, item);
            });
        } catch (error) {
            console.error('Failed to fetch ad units for placement sizes:', error);
            showToast('Could not load ad unit sizes from placements', 'error');
        }
    }

    // Now extract sizes from all placement ad units
    for (const placementId of placementIds) {
        const placement = inventoryCache.placements.get(placementId);
        if (placement && placement.metadata && placement.metadata.ad_unit_ids) {
            for (const adUnitId of placement.metadata.ad_unit_ids) {
                const adUnit = inventoryCache.adUnits.get(adUnitId);

                // Extract sizes from this ad unit using helper function
                if (adUnit && adUnit.metadata && adUnit.metadata.sizes) {
                    addSizesToCache(adUnit.metadata.sizes);
                }
            }
        }
    }

    // Update legacy UI (size chips panel)
    updateSizeChipsPanel();
    updateFormatMatchIndicators();

    // Pass extracted sizes to format template picker (AdCP 2.5 parameterized formats)
    if (window.formatPickerIntegration && inventoryCache && inventoryCache.extractedSizes.size > 0) {
        const sizesArray = Array.from(inventoryCache.extractedSizes);
        console.log('[FormatPicker] Auto-selecting sizes from inventory:', sizesArray);
        window.formatPickerIntegration.addSizesFromInventory(sizesArray);
    }
}

/**
 * Update the size chips panel display
 */
function updateSizeChipsPanel() {
    const panel = document.getElementById('size-filter-panel');

    // Early return if panel doesn't exist (e.g., when using format template picker instead)
    if (!panel) return;

    if (!inventoryCache || inventoryCache.extractedSizes.size === 0) {
        panel.style.display = 'none';
        return;
    }

    panel.style.display = 'block';

    // Sort sizes by count (most common first), then alphabetically
    const sortedSizes = Array.from(inventoryCache.extractedSizes).sort((a, b) => {
        const countA = inventoryCache.sizeUnitCounts.get(a) || 0;
        const countB = inventoryCache.sizeUnitCounts.get(b) || 0;
        if (countB !== countA) return countB - countA;
        return a.localeCompare(b);
    });

    const chipsContainer = document.getElementById('size-chips-container');
    if (!chipsContainer) return;

    chipsContainer.innerHTML = sortedSizes.map(sizeKey => {
        const count = inventoryCache.sizeUnitCounts.get(sizeKey) || 0;
        const displaySize = sizeKey.replace('x', '√ó');

        return `
            <button type="button" class="size-chip active" data-size="${sizeKey}">
                <span class="size-label">${displaySize}</span>
                <span class="unit-count">(${count} ${count === 1 ? 'unit' : 'units'})</span>
            </button>
        `;
    }).join('');
}

/**
 * Add match indicators to format cards
 */
function updateFormatMatchIndicators() {
    const formatCards = document.querySelectorAll('.format-card');

    formatCards.forEach(card => {
        // Get dimensions from data attribute (most reliable source)
        const dataDimensions = card.getAttribute('data-dimensions') || '';

        // Also try to extract from format name/label as fallback
        const formatName = card.querySelector('.format-checkbox')?.value || '';
        const formatLabel = card.querySelector('strong')?.textContent || '';
        const allText = `${dataDimensions} ${formatLabel} ${formatName}`;

        // Extract sizes from all available sources
        const formatSizes = extractSizesFromFormatName(allText);

        // Check if any format size matches inventory sizes
        const matches = formatSizes.some(size => inventoryCache && inventoryCache.extractedSizes.has(size));

        card.classList.toggle('matches-inventory', matches);
    });

    // Update the count after adding indicators
    updateMatchingFormatsCount();

    // Show/hide the "Select All Matching" button
    const matchingCount = document.querySelectorAll('.format-card.matches-inventory').length;
    const selectMatchingBtn = document.getElementById('select-matching-formats-btn');
    if (selectMatchingBtn) {
        selectMatchingBtn.style.display = matchingCount > 0 ? 'inline-block' : 'none';
    }
}

/**
 * Extract size strings from format name (e.g., "Display 300x250" -> ["300x250"])
 */
function extractSizesFromFormatName(formatText) {
    const sizes = [];
    // Match patterns like 300x250, 300√ó250, 300 x 250
    const matches = formatText.matchAll(/(\d+)\s*[x√ó]\s*(\d+)/gi);
    for (const match of matches) {
        sizes.push(`${match[1]}x${match[2]}`);
    }
    return sizes;
}

/**
 * Update the count of matching formats
 */
function updateMatchingFormatsCount() {
    const matchingCards = document.querySelectorAll('.format-card.matches-inventory');
    const totalCards = document.querySelectorAll('.format-card').length;

    const countEl = document.getElementById('matching-formats-count');
    if (countEl) {
        countEl.textContent = `${matchingCards.length} matching / ${totalCards} total formats`;
    }
}

// Initialize inventory cache when inventory picker is ready
document.addEventListener('DOMContentLoaded', function() {
    if (window.inventoryPicker && window.inventoryPicker.cache) {
        inventoryCache = window.inventoryPicker.cache;
        inventoryCache.extractedSizes = new Set(); // All unique sizes from selected inventory
        inventoryCache.sizeUnitCounts = new Map(); // size -> count of units with that size

        // Set up callback for size extraction after inventory selection
        window.inventoryPicker.setOnApplyCallback(function(selectedIds, type) {
            extractSizesFromInventory();
        });
    }

    // Handle country selection mutual exclusion
    const countriesSelect = document.getElementById('countries');
    if (countriesSelect) {
        countriesSelect.addEventListener('change', function() {
            const selectedOptions = Array.from(this.selectedOptions).map(opt => opt.value);

            // If "ALL" is selected with others, deselect all others
            if (selectedOptions.includes('ALL') && selectedOptions.length > 1) {
                // Clear all selections and just select ALL
                Array.from(this.options).forEach(opt => opt.selected = false);
                this.options[0].selected = true; // Select "All Countries"
            }
            // If specific countries are selected, deselect ALL
            else if (!selectedOptions.includes('ALL') && selectedOptions.length > 0) {
                this.options[0].selected = false; // Deselect "All Countries"
            }
        });
    }
});

// Inventory mode toggle functionality
function toggleInventoryMode() {
    const mode = document.querySelector('input[name="inventory_mode"]:checked').value;
    const profileSelection = document.getElementById('inventory-profile-selection');
    const manualSection = document.getElementById('manual-inventory-section');
    const formatsSection = document.getElementById('creative-formats-section');

    // Hide all sections first
    profileSelection.style.display = 'none';
    manualSection.style.display = 'none';
    formatsSection.style.display = 'none';

    if (mode === 'profile') {
        // Use existing profile - show dropdown only
        profileSelection.style.display = 'block';
    } else if (mode === 'create_profile') {
        // Create new profile - open inventory profile editor
        profileSelection.style.display = 'none';
        manualSection.style.display = 'none';
        formatsSection.style.display = 'none';
        // TODO: Open inventory profile editor modal
        alert('Opening inventory profile creator...\n\nThis will open the inventory profile editor where you can configure inventory, formats, and properties. Once saved, the new profile will be automatically selected for this product.');
        // For now, fallback to profile mode after alert
        document.querySelector('input[name="inventory_mode"][value="profile"]').checked = true;
        profileSelection.style.display = 'block';
    } else {
        // Custom mode - show manual inventory + formats
        manualSection.style.display = 'block';
        formatsSection.style.display = 'block';
    }
}

// Inventory picker functionality
let currentPickerType = null;

function openInventoryPicker(type) {
    currentPickerType = type;
    const modal = document.getElementById('inventory-picker-modal');
    const title = document.getElementById('picker-modal-title');
    const treeControls = document.getElementById('tree-controls');

    title.textContent = type === 'ad_unit' ? 'Select Ad Units' : 'Select Placements';

    // Show/hide tree controls based on type
    if (type === 'ad_unit') {
        treeControls.style.display = 'flex';
    } else {
        treeControls.style.display = 'none';
    }

    // Clear search
    const searchInput = document.getElementById('picker-search');
    if (searchInput) {
        searchInput.value = '';
    }

    // Load inventory
    loadInventory(type);

    // Show modal
    modal.style.display = 'flex';
}

function closeInventoryPicker() {
    document.getElementById('inventory-picker-modal').style.display = 'none';
    currentPickerType = null;
}

function loadInventory(type, search = '') {
    const list = document.getElementById('inventory-list');
    list.innerHTML = '<div style="padding: 2rem; text-align: center; color: #666;">Loading...</div>';

    if (type === 'ad_unit') {
        // Load hierarchical tree for ad units
        loadInventoryTree();
    } else {
        // Load flat list for placements (keep existing behavior)
        const url = `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=${type}${search ? '&search=' + encodeURIComponent(search) : ''}`;

        fetch(url, { credentials: 'same-origin' })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">${data.error}</div>`;
                    return;
                }

                if (data.items.length === 0) {
                    const inventoryUrl = "{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}";
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">No items found. <a href="${inventoryUrl}">Sync inventory</a> first.</div>`;
                    return;
                }

                // Cache all items for later use (including metadata)
                data.items.forEach(item => {
                    inventoryCache.placements.set(item.id, item);
                });

                // Get currently selected IDs
                const fieldId = 'targeted_placement_ids';
                const field = document.getElementById(fieldId);
                const fieldValue = field ? field.value : '';
                const selectedIds = new Set(fieldValue.split(',').filter(Boolean));

                list.innerHTML = data.items.map(item => {
                    // Show ad unit count for placements
                    let metadataHtml = '';
                    if (item.metadata && item.metadata.ad_unit_ids) {
                        const count = item.metadata.ad_unit_ids.length;
                        metadataHtml = `<br><small style="color: #2196f3; font-weight: 500;">${count} ad ${count === 1 ? 'unit' : 'units'}</small>`;
                    }

                    return `
                    <label class="inventory-item" style="display: flex; align-items: center; padding: 0.75rem; border-bottom: 1px solid #eee; cursor: pointer;">
                        <input type="checkbox"
                               value="${item.id}"
                               data-sizes='${item.metadata && item.metadata.sizes ? JSON.stringify(item.metadata.sizes) : '[]'}'
                               data-path='${item.path ? JSON.stringify(item.path) : '[]'}'
                               ${selectedIds.has(item.id) ? 'checked' : ''}
                               style="margin-right: 0.75rem;">
                        <div style="flex: 1;">
                            <strong>${item.name}</strong> <small style="color: #666;">(${item.id})</small>
                            ${item.path && item.path.length > 1 ? `<br><small style="color: #666;">${item.path.join(' > ')}</small>` : ''}
                            ${metadataHtml}
                        </div>
                    </label>
                `}).join('');
            })
            .catch(error => {
                list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">Error loading inventory: ${error.message}</div>`;
            });
    }
}

// Load hierarchical tree structure for ad units with optional search
let isLoadingTree = false; // Guard against double-loading
function loadInventoryTree(searchTerm = '') {
    if (isLoadingTree) {
        return;
    }

    isLoadingTree = true;
    const list = document.getElementById('inventory-list');

    // Build URL with search parameter if provided
    const baseUrl = `{{ url_for('inventory.get_inventory_tree', tenant_id=tenant_id) }}`;
    const url = searchTerm ? `${baseUrl}?search=${encodeURIComponent(searchTerm)}` : baseUrl;

    // Show loading indicator
    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">
        <div class="spinner-border spinner-border-sm" role="status" style="margin-right: 0.5rem;"></div>
        ${searchTerm ? 'Searching...' : 'Loading ad units...'}
    </div>`;

    fetch(url, { credentials: 'same-origin' })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">${data.error}</div>`;
                return;
            }

            if (!data.root_units || data.root_units.length === 0) {
                if (searchTerm) {
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">No ad units found matching "${searchTerm}".</div>`;
                } else {
                    const inventoryUrl = "{{ url_for('inventory.inventory_browser', tenant_id=tenant_id) }}";
                    list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #666;">No ad units found. <a href="${inventoryUrl}">Sync inventory</a> first.</div>`;
                }
                return;
            }

            // Get currently selected IDs
            const field = document.getElementById('targeted_ad_unit_ids');
            const fieldValue = field ? field.value : '';
            const selectedIds = new Set(fieldValue.split(',').filter(Boolean));

            // Render tree (will be auto-expanded if search is active)
            list.innerHTML = renderAdUnitTree(data.root_units, selectedIds, 0, data.search_active);

            // Auto-expand based on context
            // Use requestAnimationFrame + setTimeout to ensure DOM is fully rendered
            requestAnimationFrame(() => {
                setTimeout(() => {
                    if (data.search_active) {
                        // Search active: expand all to show matches
                        expandAllTreeNodes();
                    } else if (selectedIds.size > 0) {
                        // No search but items selected: expand to selected
                        expandToSelected();
                    }
                    // Otherwise keep collapsed (default)
                }, 200);
            });

            isLoadingTree = false; // Reset guard
        })
        .catch(error => {
            list.innerHTML = `<div style="padding: 2rem; text-align: center; color: #dc3545;">Error loading inventory: ${error.message}</div>`;
            isLoadingTree = false; // Reset guard on error
        });
}

// Render hierarchical ad unit tree (recursive)
function renderAdUnitTree(units, selectedIds, depth = 0, searchActive = false) {
    return units.map(unit => {
        const hasChildren = unit.children && unit.children.length > 0;
        const isChecked = selectedIds.has(unit.id);
        const matchedSearch = unit.matched_search || false;

        // Store unit in cache for later use with sizes from tree API
        // Always update cache to ensure we have children array from tree API
        // (flat list API responses don't include children)
        inventoryCache.adUnits.set(unit.id, {
            id: unit.id,
            name: unit.name,
            path: unit.path,
            metadata: { sizes: unit.sizes || [] }, // Sizes from tree API response
            children: unit.children || [] // Store children for recursive size extraction
        });

        // Add highlight class if this node matched the search
        const highlightClass = matchedSearch ? 'search-match' : '';

        // Build HTML using CSS classes for styling
        let html = `
            <div class="tree-node ${highlightClass}" data-unit-id="${unit.id}" data-depth="${depth}">
                <div class="tree-node-header">
                    ${hasChildren ? `
                        <span class="tree-toggle" onclick="event.stopPropagation(); toggleTreeNode('${unit.id}')">
                            <span class="toggle-icon">‚ñ∂</span>
                            <span class="loading-spinner"></span>
                        </span>
                    ` : '<span class="tree-spacer"></span>'}
                    <label class="tree-node-label" onclick="event.stopPropagation();">
                        <input type="checkbox"
                               class="ad-unit-checkbox"
                               value="${unit.id}"
                               data-name="${unit.name}"
                               data-path='${JSON.stringify(unit.path || [unit.name])}'
                               ${isChecked ? 'checked' : ''}
                               onchange="handleTreeCheckboxChange(this)">
                        <div class="tree-node-content">
                            <span class="tree-node-name">
                                ${unit.name}
                                ${unit.code && unit.code !== unit.name ? `<span class="tree-node-code">${unit.code}</span>` : ''}
                            </span>
                        </div>
                    </label>
                </div>
                ${hasChildren ? `
                    <div class="tree-children">
                        ${renderAdUnitTree(unit.children, selectedIds, depth + 1, searchActive)}
                    </div>
                ` : ''}
            </div>
        `;

        return html;
    }).join('');
}

// Toggle tree node expand/collapse with loading indicator
function toggleTreeNode(unitId) {
    const node = document.querySelector(`.tree-node[data-unit-id="${unitId}"]`);
    if (!node) return;

    const children = node.querySelector('.tree-children');
    const toggle = node.querySelector('.tree-toggle');
    const toggleIcon = node.querySelector('.toggle-icon');

    if (!children || !toggle || !toggleIcon) return;

    // Check if currently expanded (display is 'block', not 'none' or empty)
    const isExpanded = children.style.display === 'block';

    if (isExpanded) {
        // Collapse - immediate, no loading needed
        children.style.display = 'none';
        toggleIcon.textContent = '‚ñ∂';
        toggle.classList.remove('loading');
    } else {
        // Expand - show loading spinner briefly for visual feedback
        toggle.classList.add('loading');

        // Use setTimeout to show spinner and allow UI to update
        setTimeout(() => {
            children.style.display = 'block';
            toggleIcon.textContent = '‚ñº';

            // Remove loading after a short delay to ensure visibility
            setTimeout(() => {
                toggle.classList.remove('loading');
            }, 150);
        }, 50);
    }
}

// Handle tree checkbox change
function handleTreeCheckboxChange(checkbox) {
    // Just update the checked state - selection will be applied on "Apply Selection"
    // No need to do anything special here
}

// Expand all tree nodes
function expandAllTreeNodes() {
    const allChildren = document.querySelectorAll('.tree-children');
    const allToggles = document.querySelectorAll('.toggle-icon');

    allChildren.forEach(children => {
        children.style.display = 'block';
    });

    allToggles.forEach(toggle => {
        toggle.textContent = '‚ñº';
    });
}

// Collapse all tree nodes
function collapseAllTreeNodes() {
    const allChildren = document.querySelectorAll('.tree-children');
    const allToggles = document.querySelectorAll('.toggle-icon');

    allChildren.forEach(children => {
        children.style.display = 'none';
    });

    allToggles.forEach(toggle => {
        toggle.textContent = '‚ñ∂';
    });
}

// Expand tree to show selected items
function expandToSelected() {
    // First collapse all
    collapseAllTreeNodes();

    // Find all checked checkboxes
    const checkedBoxes = document.querySelectorAll('#inventory-list .ad-unit-checkbox:checked');

    if (checkedBoxes.length === 0) {
        return;
    }

    // For each checked box, expand the path from root to that node
    checkedBoxes.forEach(checkbox => {
        let node = checkbox.closest('.tree-node');

        // Collect all ancestor nodes first
        const ancestors = [];
        let current = node;

        while (current) {
            ancestors.unshift(current); // Add to front (so root is first)

            // Find parent by going up through .tree-children
            const parentChildren = current.parentElement;
            if (parentChildren && parentChildren.classList.contains('tree-children')) {
                current = parentChildren.closest('.tree-node');
            } else {
                // Reached root
                break;
            }
        }

        // Now expand from root down to the selected node
        ancestors.forEach(ancestor => {
            // Find this ancestor's children container
            const childrenContainer = ancestor.querySelector(':scope > .tree-children');
            if (childrenContainer) {
                childrenContainer.style.display = 'block';
            }

            // Update toggle icon
            const toggle = ancestor.querySelector(':scope > .tree-node-header > .tree-toggle > .toggle-icon');
            if (toggle) {
                toggle.textContent = '‚ñº';
            }
        });
    });
}

// Search and filter tree nodes
function searchTreeNodes(searchTerm) {
    const term = searchTerm.toLowerCase().trim();
    const allNodes = document.querySelectorAll('.tree-node');

    if (!term) {
        // Show all nodes and collapse all
        allNodes.forEach(node => {
            node.style.display = 'block';
        });
        collapseAllTreeNodes();
        return;
    }

    // First pass: mark matching nodes
    allNodes.forEach(node => {
        const header = node.querySelector('.tree-node-header');
        const text = header ? header.textContent.toLowerCase() : '';
        const matches = text.includes(term);

        node.dataset.matches = matches ? 'true' : 'false';
        node.dataset.hasMatchingChild = 'false';
    });

    // Second pass: mark parents with matching children
    allNodes.forEach(node => {
        if (node.dataset.matches === 'true') {
            // Mark all parents as having matching children
            let parent = node.parentElement;
            while (parent && parent.classList.contains('tree-children')) {
                const parentNode = parent.closest('.tree-node');
                if (parentNode) {
                    parentNode.dataset.hasMatchingChild = 'true';
                    parent = parentNode.parentElement;
                } else {
                    break;
                }
            }
        }
    });

    // Third pass: show/hide based on matches
    allNodes.forEach(node => {
        const matches = node.dataset.matches === 'true';
        const hasMatchingChild = node.dataset.hasMatchingChild === 'true';

        if (matches || hasMatchingChild) {
            node.style.display = 'block';
            // Expand to show matching children
            if (hasMatchingChild) {
                const children = node.querySelector('.tree-children');
                const toggle = node.querySelector('.toggle-icon');
                if (children && toggle) {
                    children.style.display = 'block';
                    toggle.textContent = '‚ñº';
                }
            }
        } else {
            node.style.display = 'none';
        }
    });
}

async function applyInventorySelection() {
    const checkboxes = document.querySelectorAll('#inventory-list input[type="checkbox"]:checked');
    const selectedIds = Array.from(checkboxes).map(cb => cb.value);
    const selectedNames = Array.from(checkboxes).map(cb => {
        // For tree nodes, get name from data attribute or label text
        const dataName = cb.getAttribute('data-name');
        if (dataName) {
            return dataName;
        }
        // Fallback: get from label (for flat list items)
        const label = cb.closest('label');
        const strong = label ? label.querySelector('strong') : null;
        return strong ? strong.textContent : cb.value;
    });

    if (currentPickerType === 'ad_unit') {
        document.getElementById('targeted_ad_unit_ids').value = selectedIds.join(',');
        updateSelectedDisplay('selected-ad-units', selectedNames, selectedIds);
    } else {
        document.getElementById('targeted_placement_ids').value = selectedIds.join(',');
        updateSelectedDisplay('selected-placements', selectedNames, selectedIds);
    }

    // Extract sizes from selected inventory and update UI (if function exists)
    if (typeof extractSizesFromInventory === 'function') {
        await extractSizesFromInventory();
    }

    closeInventoryPicker();
}

function updateSelectedDisplay(containerId, names, ids) {
    const container = document.getElementById(containerId);
    const isAdUnit = containerId === 'selected-ad-units';

    if (names.length === 0) {
        container.innerHTML = '<span style="color: #999;">No items selected</span>';
    } else {
        container.innerHTML = names.map((name, idx) => {
            const id = ids[idx];
            let sizesText = '';

            // Show sizes inline for ad units
            if (isAdUnit) {
                const item = inventoryCache.adUnits.get(id);
                console.log('[DEBUG] updateSelectedDisplay: id=', id, 'item=', item);
                console.log('[DEBUG] inventoryCache.adUnits size:', inventoryCache.adUnits.size);
                // Check both item.sizes (raw API format) and item.metadata.sizes (normalized format)
                const itemSizes = item && (item.sizes || (item.metadata && item.metadata.sizes)) || [];
                if (itemSizes.length > 0) {
                    const sizeStrings = itemSizes
                        .map(s => `${s.width}√ó${s.height}`)
                        .join(', ');
                    sizesText = ` <small style="color: #28a745; font-weight: 500;">(${sizeStrings})</small>`;
                }
            } else {
                // Show ad unit count for placements
                const item = inventoryCache.placements.get(id);
                if (item && item.metadata && item.metadata.ad_unit_ids) {
                    const count = item.metadata.ad_unit_ids.length;
                    sizesText = ` <small style="color: #666;">(${count} ad ${count === 1 ? 'unit' : 'units'})</small>`;
                }
            }

            return `
                <span class="selected-item" style="display: inline-block; background: #e7f3ff; color: #000; padding: 0.25rem 0.5rem; margin: 0.25rem; border-radius: 4px;">
                    ${name} <small style="color: #666;">(${id})</small>${sizesText}
                    <button type="button" onclick="removeSelectedItem('${containerId}', '${id}')" style="border: none; background: none; color: #666; cursor: pointer; margin-left: 0.25rem;">√ó</button>
                </span>
            `;
        }).join('');
    }
}

async function autoSuggestFormats(selectedCheckboxes) {
    // Collect all ad unit constraints (type + max dimensions)
    const adUnitConstraints = []; // [{type: 'display', maxWidth: 970, maxHeight: 250}, ...]
    const includeChildren = document.querySelector('input[name="include_descendants"]')?.checked;

    // First, collect constraints from directly selected ad units
    const selectedPaths = [];
    selectedCheckboxes.forEach(cb => {
        const sizesData = cb.getAttribute('data-sizes');
        const pathData = cb.getAttribute('data-path');

        // Extract path for child lookup
        let path = [];
        if (pathData) {
            try {
                path = JSON.parse(pathData);
            } catch (e) {
                console.warn('Failed to parse path data:', e);
                const label = cb.closest('label');
                const name = label.querySelector('strong').textContent.trim();
                path = [name];
            }
        }
        if (path.length > 0) {
            selectedPaths.push(path);
        }

        // Collect size constraints from this ad unit
        if (sizesData) {
            try {
                const sizes = JSON.parse(sizesData);
                sizes.forEach(size => {
                    // For now, assume all ad units are 'display' type
                    // In future, could get type from ad unit metadata
                    adUnitConstraints.push({
                        type: 'display',
                        maxWidth: size.width,
                        maxHeight: size.height
                    });
                });
            } catch (e) {
                console.warn('Failed to parse size data:', e);
            }
        }
    });

    // If "include children" is checked, fetch all ad units and find children
    if (includeChildren && selectedPaths.length > 0) {
        try {
            const url = `{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=ad_unit`;
            const response = await fetch(url, { credentials: 'same-origin' });
            const data = await response.json();

            if (data.items) {
                data.items.forEach(item => {
                    if (item.path && item.path.length > 0) {
                        for (const selectedPath of selectedPaths) {
                            const isChild = selectedPath.every((segment, idx) => item.path[idx] === segment)
                                         && item.path.length > selectedPath.length;

                            if (isChild && item.metadata && item.metadata.sizes) {
                                item.metadata.sizes.forEach(size => {
                                    adUnitConstraints.push({
                                        type: 'display',
                                        maxWidth: size.width,
                                        maxHeight: size.height
                                    });
                                });
                                break;
                            }
                        }
                    }
                });
            }
        } catch (e) {
            console.warn('Failed to fetch child ad units:', e);
        }
    }

    // Always show formats, but only show search targets if we have constraints
    const container = document.getElementById('formats-container');
    const searchTargets = document.getElementById('format-search-targets');
    const searchTargetList = document.getElementById('search-target-list');
    const searchBox = document.getElementById('format-search-box');

    container.style.display = 'grid';
    searchBox.style.display = 'block';

    // If no constraints, show all formats without filtering
    if (adUnitConstraints.length === 0) {
        searchTargets.style.display = 'none';
        // Show all formats
        const formatCheckboxes = document.querySelectorAll('#formats-container input[type="checkbox"]');
        formatCheckboxes.forEach(checkbox => {
            const card = checkbox.closest('.format-card');
            if (card) {
                card.style.display = 'block';
            }
        });
        updateFormatSummary(formatCheckboxes.length);
        return;
    }

    searchTargets.style.display = 'block';

    // Helper: Check if format fits within any ad unit constraint
    function formatFitsConstraint(formatWidth, formatHeight, formatType) {
        return adUnitConstraints.some(constraint => {
            // Type compatibility check
            // - Exact match (display ‚Üî display, video ‚Üî video, etc.)
            // - Generative formats can serve in display ad units
            // - Universal formats can serve anywhere
            const typeMatches =
                formatType === constraint.type ||
                (formatType === 'generative' && constraint.type === 'display') ||
                formatType === 'universal';

            if (!typeMatches) return false;

            // Format must fit within ad unit dimensions
            return formatWidth <= constraint.maxWidth && formatHeight <= constraint.maxHeight;
        });
    }

    // Group constraints by type for display
    const constraintsByType = {};
    adUnitConstraints.forEach(c => {
        if (!constraintsByType[c.type]) {
            constraintsByType[c.type] = [];
        }
        constraintsByType[c.type].push(`${c.maxWidth}√ó${c.maxHeight}`);
    });

    // Display search targets grouped by type
    const searchTargetHTML = Object.entries(constraintsByType)
        .map(([type, sizes]) => {
            // Get unique sizes
            const uniqueSizes = [...new Set(sizes)];
            return `
                <span style="background: #1565c0; color: white; padding: 0.4rem 0.75rem; border-radius: 4px; font-size: 0.9rem;">
                    ${type} formats ‚â§ ${uniqueSizes.join(', ')}
                </span>
            `;
        }).join('');

    searchTargetList.innerHTML = searchTargetHTML;
    searchTargets.style.display = 'block';

    // Filter and display matching formats
    const formatCards = document.querySelectorAll('.format-card');
    container.style.display = 'grid';

    // Show format actions
    const formatActions = document.getElementById('format-actions');
    if (formatActions) {
        formatActions.style.display = 'flex';
    }
    let matchingCount = 0;
    let autoCheckedCount = 0;

    console.log(`[DEBUG] Filtering ${formatCards.length} format cards`);
    console.log(`[DEBUG] Ad unit constraints:`, constraintsByType);

    formatCards.forEach((card, index) => {
        const dimensions = card.getAttribute('data-dimensions');
        const type = card.getAttribute('data-type');
        const checkbox = card.querySelector('input[type="checkbox"]');
        const name = card.querySelector('strong').textContent;

        if (index < 5) {
            console.log(`[DEBUG] Format ${index}: "${name}" type="${type}" dimensions="${dimensions}"`);
        }

        if (dimensions) {
            // Parse format dimensions (e.g., "300x250")
            const [widthStr, heightStr] = dimensions.split('x');
            const formatWidth = parseInt(widthStr, 10);
            const formatHeight = parseInt(heightStr, 10);

            if (index < 5) {
                console.log(`[DEBUG] Format ${index}: parsed w=${formatWidth} h=${formatHeight}`);
            }

            if (formatFitsConstraint(formatWidth, formatHeight, type)) {
                // This format fits - show it
                matchingCount++;
                card.style.display = 'block';

                // Auto-check if not already checked
                if (!checkbox.checked) {
                    checkbox.checked = true;
                    autoCheckedCount++;
                    // Add visual feedback
                    card.style.borderColor = '#28a745';
                    card.style.backgroundColor = '#f0fff4';
                    setTimeout(() => {
                        card.style.borderColor = '#007bff';
                        card.style.backgroundColor = '#e7f3ff';
                    }, 2000);
                }
            } else {
                // This format doesn't fit - hide it but preserve checked state
                // User might have selected it deliberately, so don't uncheck it
                // IMPORTANT: Don't disable checkbox - disabled inputs don't submit with form!
                card.style.display = 'none';
                // checkbox.disabled = true; // REMOVED - would prevent form submission
                // DO NOT uncheck: checkbox.checked = false;
            }
        } else {
            // No dimensions - hide it but preserve checked state
            // IMPORTANT: Don't disable checkbox - disabled inputs don't submit with form!
            card.style.display = 'none';
            // checkbox.disabled = true; // REMOVED - would prevent form submission
            // DO NOT uncheck: checkbox.checked = false;
        }
    });

    // Update summary
    updateFormatSummary(matchingCount);

    if (autoCheckedCount > 0) {
        console.log(`Auto-checked ${autoCheckedCount} matching format(s) from ${matchingCount} compatible formats`);
        console.log(`Constraints: ${JSON.stringify(constraintsByType)}`);
    }
}

function updateFormatSummary(matchingCount) {
    const summary = document.getElementById('format-summary');
    const countSpan = document.getElementById('format-count');

    // Only count visible checked formats
    const checkedCount = Array.from(document.querySelectorAll('.format-card input[type="checkbox"]:checked'))
        .filter(cb => cb.closest('.format-card').style.display !== 'none')
        .length;

    countSpan.textContent = checkedCount;

    if (checkedCount > 0) {
        summary.style.display = 'block';
    } else {
        summary.style.display = 'none';
    }
}

async function removeSelectedItem(containerId, idToRemove) {
    const isAdUnit = containerId === 'selected-ad-units';
    const hiddenInput = document.getElementById(isAdUnit ? 'targeted_ad_unit_ids' : 'targeted_placement_ids');
    const currentIds = hiddenInput.value.split(',').filter(Boolean);
    const newIds = currentIds.filter(id => id !== idToRemove);
    hiddenInput.value = newIds.join(',');

    // Refresh display - get names from inventory cache instead of DOM
    const cache = isAdUnit ? inventoryCache.adUnits : inventoryCache.placements;
    const selectedNames = newIds.map(id => {
        const item = cache.get(id);
        return item ? item.name : id;
    });

    updateSelectedDisplay(containerId, selectedNames, newIds);

    // Extract sizes from remaining selected inventory (both ad units and placements)
    // This ensures format sizes update when items are removed
    if (typeof extractSizesFromInventory === 'function') {
        await extractSizesFromInventory();
    }
}

// Search handler - trigger search on button click or Enter key
function triggerSearch() {
    const searchInput = document.getElementById('picker-search');
    if (!searchInput) return;

    const searchValue = searchInput.value;

    if (currentPickerType === 'ad_unit') {
        // For tree view, reload from server with search parameter
        loadInventoryTree(searchValue);
    } else {
        // For flat list (placements), reload from server
        loadInventory(currentPickerType, searchValue);
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('picker-search');
    if (searchInput) {
        // Trigger search on Enter key
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                triggerSearch();
            }
        });
    }

    // Add event listeners to format checkboxes to update summary
    const formatsContainer = document.getElementById('formats-container');
    if (formatsContainer) {
        formatsContainer.addEventListener('change', function(e) {
            if (e.target.type === 'checkbox') {
                // Update summary when formats are manually checked/unchecked
                const visibleFormats = Array.from(document.querySelectorAll('.format-card'))
                    .filter(card => card.style.display !== 'none').length;
                updateFormatSummary(visibleFormats);
            }
        });
    }

    // Handle inventory profile selection - toggle manual sections
    const profileSelect = document.getElementById('inventory_profile_id');
    if (profileSelect) {
        profileSelect.addEventListener('change', function() {
            handleProfileChange(this.value);
        });

        // Trigger on load if profile is already selected
        if (profileSelect.value) {
            handleProfileChange(profileSelect.value);
        }
    }

    // Restore form data from validation errors
    {% if form_data %}
    (function() {
        const formData = {{ form_data | tojson }};

        // Restore pricing options if present
        if (formData) {
            // Find all pricing option fields (pricing_model_0, pricing_model_1, etc.)
            let pricingIndex = 0;
            while (formData['pricing_model_' + pricingIndex] !== undefined) {
                // Add pricing option UI
                addPricingOption({
                    pricing_model: formData['pricing_model_' + pricingIndex],
                    currency: formData['currency_' + pricingIndex],
                    rate: formData['rate_' + pricingIndex],
                    is_fixed: formData['pricing_model_' + pricingIndex] && !formData['pricing_model_' + pricingIndex].includes('auction')
                });
                pricingIndex++;
            }

            // Restore countries selection
            if (formData.countries) {
                const countriesSelect = document.getElementById('countries');
                if (countriesSelect) {
                    const countries = typeof formData.countries === 'string' ?
                        formData.countries.split(',') : formData.countries;
                    Array.from(countriesSelect.options).forEach(option => {
                        if (countries.includes(option.value)) {
                            option.selected = true;
                        }
                    });
                }
            }

            // Restore dynamic product checkbox
            if (formData.is_dynamic) {
                const dynamicCheckbox = document.getElementById('is_dynamic');
                if (dynamicCheckbox) {
                    dynamicCheckbox.checked = formData.is_dynamic === 'on' || formData.is_dynamic === true;
                    dynamicCheckbox.dispatchEvent(new Event('change'));
                }
            }
        }
    })();
    {% endif %}
});

// Handle inventory profile selection change (toggle manual sections)
function handleProfileChange(profileId) {
    console.log('handleProfileChange called with profileId:', profileId);
    const hasProfile = profileId !== '';
    const manualSection = document.getElementById('manual-inventory-section');
    const formatsSection = document.getElementById('creative-formats-section');
    const profilePreview = document.getElementById('inventory-profile-preview');

    console.log('Found elements:', {
        manualSection: !!manualSection,
        formatsSection: !!formatsSection,
        profilePreview: !!profilePreview,
        hasProfile: hasProfile
    });

    // Toggle sections based on profile selection
    if (hasProfile) {
        // Profile selected - hide manual sections
        console.log('Hiding manual sections, showing profile preview');
        if (manualSection) manualSection.style.display = 'none';
        if (formatsSection) formatsSection.style.display = 'none';
        if (profilePreview) {
            profilePreview.style.display = 'block';
            loadProfilePreview(profileId);
        }
    } else {
        // No profile - show manual sections
        console.log('Showing manual sections, hiding profile preview');
        if (manualSection) manualSection.style.display = 'block';
        if (formatsSection) formatsSection.style.display = 'block';
        if (profilePreview) profilePreview.style.display = 'none';
    }
}

// Load and display inventory profile preview
async function loadProfilePreview(profileId) {
    try {
        const url = `{{ url_for('inventory_profiles.preview_inventory_profile', tenant_id=tenant_id, profile_id=0) }}`.replace('/0/', `/${profileId}/`);
        const response = await fetch(url, { credentials: 'same-origin' });
        const data = await response.json();

        if (data.error) {
            console.error('Failed to load profile preview:', data.error);
            return;
        }

        // Update preview display
        document.getElementById('profile-preview-name').textContent = data.name;
        document.getElementById('profile-preview-description').textContent = data.description || 'No description';

        // Build details HTML
        const details = [];
        if (data.ad_unit_count > 0) {
            details.push(`<span><strong>${data.ad_unit_count}</strong> ad unit${data.ad_unit_count !== 1 ? 's' : ''}</span>`);
        }
        if (data.placement_count > 0) {
            details.push(`<span><strong>${data.placement_count}</strong> placement${data.placement_count !== 1 ? 's' : ''}</span>`);
        }
        if (data.format_count > 0) {
            details.push(`<span><strong>${data.format_count}</strong> format${data.format_count !== 1 ? 's' : ''}</span>`);
        }
        document.getElementById('profile-preview-details').innerHTML = details.join('<span style="color: #ccc;">|</span>');

        // Update edit link
        const editLink = document.getElementById('profile-preview-edit-link');
        editLink.href = `{{ url_for('inventory_profiles.edit_inventory_profile', tenant_id=tenant_id, profile_id=0) }}`.replace('/0/', `/${profileId}/`);

    } catch (e) {
        console.error('Failed to load profile preview:', e);
    }
}

// Pricing Options Management (AdCP PR #88)
// Moved here so it's available for both create and edit modes
let pricingOptionIndex = 0;

function addPricingOption(existingData = null) {
    const container = document.getElementById('pricing-options-container');
    const index = pricingOptionIndex++;

    const optionHtml = `
        <div class="pricing-option" id="pricing-option-${index}" style="border: 1px solid #dee2e6; border-radius: 4px; padding: 1rem; margin-bottom: 1rem; background: white;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h5 style="margin: 0;">Pricing Option #${index + 1}</h5>
                <button type="button" class="btn btn-secondary" onclick="removePricingOption(${index})" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">Remove</button>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div class="form-group">
                    <label>Pricing Model *</label>
                    <select name="pricing_model_${index}" class="pricing-model-select" onchange="updatePricingFields${index}()" required>
                        <option value="">Select...</option>
                        <optgroup label="Guaranteed (Fixed Price)">
                            <option value="cpm_fixed" ${existingData && existingData.pricing_model?.toLowerCase() === 'cpm' && existingData.is_fixed === true ? 'selected' : ''}>CPM - Fixed Rate (Cost per 1,000 impressions)</option>
                            <option value="flat_rate" ${existingData && existingData.pricing_model?.toLowerCase() === 'flat_rate' ? 'selected' : ''}>Flat Rate - Fixed Campaign Cost (Sponsorship)</option>
                        </optgroup>
                        <optgroup label="Non-Guaranteed (Auction/Bidding)">
                            <option value="cpm_auction" ${existingData && existingData.pricing_model?.toLowerCase() === 'cpm' && existingData.is_fixed === false ? 'selected' : ''}>CPM - Auction (Floor price bidding)</option>
                            <option value="vcpm" ${existingData && existingData.pricing_model?.toLowerCase() === 'vcpm' ? 'selected' : ''}>VCPM - Auction (Viewable impressions)</option>
                            <option value="cpc" ${existingData && existingData.pricing_model?.toLowerCase() === 'cpc' ? 'selected' : ''}>CPC - Auction (Cost per click)</option>
                        </optgroup>
                    </select>
                    <small style="color: #666;">All pricing models shown are supported by Google Ad Manager.</small>
                </div>

                <div class="form-group">
                    <label>Currency *</label>
                    <select name="currency_${index}" required>
                        {% for currency in currencies %}
                        <option value="{{ currency }}" ${existingData && existingData.currency === '{{ currency }}' ? 'selected' : ''}>{{ currency }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div class="form-group" id="rate-group-${index}">
                    <label>Rate *</label>
                    <input type="number" name="rate_${index}" step="0.01" min="0" placeholder="e.g., 12.50" value="${existingData && existingData.rate ? existingData.rate : ''}">
                    <small style="color: #666;">Price per unit: CPM=$12.50 per 1K imps, CPC=$2.50 per click, FLAT_RATE=$5000 total campaign</small>
                </div>

                <div class="form-group" id="floor-group-${index}" style="display: none;">
                    <label>Floor Price *</label>
                    <input type="number" name="floor_${index}" step="0.01" min="0" placeholder="Minimum bid" value="${existingData && existingData.price_guidance ? existingData.price_guidance.floor : ''}">
                    <small style="color: #666;">Minimum acceptable price</small>
                </div>

                <div class="form-group">
                    <label>Min Spend Per Package</label>
                    <input type="number" name="min_spend_${index}" step="0.01" min="0" placeholder="Optional" value="${existingData && existingData.min_spend_per_package ? existingData.min_spend_per_package : ''}">
                    <small style="color: #666;">Minimum spend required for this pricing option</small>
                </div>
            </div>
        </div>
    `;

    container.insertAdjacentHTML('beforeend', optionHtml);

    // Create dynamic update function
    window[`updatePricingFields${index}`] = function() {
        const modelSelect = document.querySelector(`select[name="pricing_model_${index}"]`);
        const rateGroup = document.getElementById(`rate-group-${index}`);
        const floorGroup = document.getElementById(`floor-group-${index}`);

        // vCPM and CPC are always auction-based (no fixed rate option)
        const value = modelSelect.value;
        const isAuction = value.includes('auction') || value === 'vcpm' || value === 'cpc';

        if (isAuction) {
            rateGroup.style.display = 'none';
            floorGroup.style.display = 'block';
            document.querySelector(`input[name="rate_${index}"]`).removeAttribute('required');
            document.querySelector(`input[name="floor_${index}"]`).setAttribute('required', '');
        } else {
            rateGroup.style.display = 'block';
            floorGroup.style.display = 'none';
            document.querySelector(`input[name="rate_${index}"]`).setAttribute('required', '');
            document.querySelector(`input[name="floor_${index}"]`).removeAttribute('required');
        }
    };

    // Initialize fields if existing data
    if (existingData) {
        window[`updatePricingFields${index}`]();
    }
}

function removePricingOption(index) {
    const element = document.getElementById(`pricing-option-${index}`);
    if (element) {
        element.remove();
    }
}

// Populate formats JSON before form submission
function prepareFormSubmission(event) {
    // Check if format picker has already populated the field
    const formatsField = document.getElementById('formats-data');
    const existingValue = formatsField ? formatsField.value : '';
    let hasFormatPickerData = false;

    try {
        const parsed = JSON.parse(existingValue);
        hasFormatPickerData = Array.isArray(parsed) && parsed.length > 0;
    } catch (e) {
        hasFormatPickerData = false;
    }

    if (hasFormatPickerData) {
        // Format picker already populated - don't overwrite
        console.log('[DEBUG] Form submission - using format picker data:', existingValue);
    } else {
        // Legacy path: Convert checked format checkboxes to JSON for backend
        const formatCheckboxes = document.querySelectorAll('.format-checkbox:checked');
        const formatsJson = Array.from(formatCheckboxes).map(cb => ({
            agent_url: cb.dataset.agentUrl || '',
            format_id: cb.dataset.formatId || ''
        }));

        // Populate the hidden field with JSON
        if (formatsField) {
            formatsField.value = JSON.stringify(formatsJson);
        }

        console.log('[DEBUG] Form submission - formats JSON (legacy):', formatsJson);
        console.log('[DEBUG] Form submission - total checked:', formatsJson.length);

        if (formatsJson.length === 0) {
            console.log('[DEBUG] NO FORMATS CHECKED ON SUBMIT');
            // Don't prevent submission, just log
        }
    }

    // Debug targeting data
    const targetingField = document.getElementById('targeting-data');
    if (targetingField) {
        console.log('[DEBUG] Form submission - targeting_template field value:', targetingField.value);
        try {
            const targetingData = JSON.parse(targetingField.value);
            console.log('[DEBUG] Form submission - parsed targeting data:', targetingData);
            if (targetingData.key_value_pairs) {
                console.log('[DEBUG] Form submission - key_value_pairs:', targetingData.key_value_pairs);
            }
        } catch (e) {
            console.error('[DEBUG] Failed to parse targeting data:', e);
        }
    } else {
        console.error('[DEBUG] targeting-data field not found!');
    }

    // Debug placement data
    console.log('[DEBUG] ===== PLACEMENT DEBUG START =====');
    const placementsField = document.getElementById('targeted_placement_ids');
    console.log('[DEBUG] Placements field element:', placementsField);
    if (placementsField) {
        const placementValue = placementsField.value;
        console.log('[DEBUG] Form submission - targeted_placement_ids field value:', placementValue);
        console.log('[DEBUG] Form submission - placement value type:', typeof placementValue);
        console.log('[DEBUG] Form submission - placement value length:', placementValue.length);
        const placementIds = placementValue.split(',').filter(Boolean);
        console.log('[DEBUG] Form submission - placement IDs array:', placementIds);
        console.log('[DEBUG] Form submission - placement count:', placementIds.length);

        if (placementIds.length === 0 && placementValue) {
            console.warn('[DEBUG] Placement field has value but split resulted in empty array!');
        }
    } else {
        console.error('[DEBUG] targeted_placement_ids field not found!');
        console.error('[DEBUG] Available form fields:', Array.from(document.getElementById('product-form').elements).map(e => e.id || e.name));
    }
    console.log('[DEBUG] ===== PLACEMENT DEBUG END =====');

    // Debug ad unit data
    console.log('[DEBUG] ===== AD UNIT DEBUG START =====');
    const adUnitsField = document.getElementById('targeted_ad_unit_ids');
    console.log('[DEBUG] Ad units field element:', adUnitsField);
    if (adUnitsField) {
        const adUnitValue = adUnitsField.value;
        console.log('[DEBUG] Form submission - targeted_ad_unit_ids field value:', adUnitValue);
        console.log('[DEBUG] Form submission - ad unit value type:', typeof adUnitValue);
        console.log('[DEBUG] Form submission - ad unit value length:', adUnitValue.length);
        const adUnitIds = adUnitValue.split(',').filter(Boolean);
        console.log('[DEBUG] Form submission - ad unit IDs array:', adUnitIds);
        console.log('[DEBUG] Form submission - ad unit count:', adUnitIds.length);

        if (adUnitIds.length === 0 && adUnitValue) {
            console.warn('[DEBUG] Ad unit field has value but split resulted in empty array!');
        }
    } else {
        console.error('[DEBUG] targeted_ad_unit_ids field not found!');
        console.error('[DEBUG] Available form fields:', Array.from(document.getElementById('product-form').elements).map(e => e.id || e.name));
    }
    console.log('[DEBUG] ===== AD UNIT DEBUG END =====');

    // Continue with form submission
    return true;
}

// Filter formats based on search input
function filterGAMFormats() {
    const searchInput = document.getElementById('format-search-input');
    const searchTerm = searchInput.value.toLowerCase();
    const formatCards = document.querySelectorAll('.format-card');
    let visibleCount = 0;

    formatCards.forEach(card => {
        const formatName = card.querySelector('strong').textContent.toLowerCase();
        const formatType = card.getAttribute('data-type').toLowerCase();
        const formatDimensions = card.getAttribute('data-dimensions') || '';

        const matches = formatName.includes(searchTerm) ||
                       formatType.includes(searchTerm) ||
                       formatDimensions.includes(searchTerm);

        if (matches) {
            card.style.display = 'block';
            visibleCount++;
        } else {
            card.style.display = 'none';
        }
    });

    // Update format count
    const checkedCount = Array.from(document.querySelectorAll('.format-card input[type="checkbox"]:checked'))
        .filter(cb => cb.closest('.format-card').style.display !== 'none')
        .length;
    document.getElementById('format-count').textContent = checkedCount;
}
</script>

{% set picker_config = {
    'tenant_id': tenant_id,
    'ad_unit_field_id': 'targeted_ad_unit_ids',
    'placement_field_id': 'targeted_placement_ids',
    'ad_unit_display_id': 'selected-ad-units',
    'placement_display_id': 'selected-placements'
} %}
{% include 'components/inventory_picker.html' %}

{% if product %}
<script>
// Pre-populate form for editing
(function() {
    const product = {{ product | tojson }};
    const config = product.implementation_config || {};
    console.log('[DEBUG] Product object:', product);
    console.log('[DEBUG] Implementation config:', config);
    console.log('[DEBUG] targeted_placement_ids type:', typeof config.targeted_placement_ids);
    console.log('[DEBUG] targeted_placement_ids value:', config.targeted_placement_ids);

    // Line item type is now automatically determined from pricing model - no need to set it

    // Set pricing values
    setTimeout(() => {
        if (product.cpm) {
            const cpmField = document.getElementById('cpm');
            if (cpmField) {
                cpmField.value = product.cpm;
                console.log('Set CPM to:', product.cpm);
            }
        }
        if (product.price_guidance && product.price_guidance.min !== undefined) {
            const floorField = document.getElementById('floor_cpm');
            if (floorField) {
                floorField.value = product.price_guidance.min;
                console.log('Set floor_cpm to:', product.price_guidance.min);
            } else {
                console.warn('floor_cpm field not found!');
            }
        }
        if (config.priority) {
            const priorityField = document.getElementById('priority');
            if (priorityField) {
                priorityField.value = config.priority;
                console.log('Set priority to:', config.priority);
            }
        }
    }, 200);

    // Set countries
    if (product.countries && product.countries.length > 0) {
        const countriesSelect = document.getElementById('countries');
        Array.from(countriesSelect.options).forEach(option => {
            if (product.countries.includes(option.value)) {
                option.selected = true;
            }
        });
    }

    // Set ad units and placements - fetch actual names from inventory
    if (config.targeted_ad_unit_ids && config.targeted_ad_unit_ids.length > 0) {
        const adUnitIds = config.targeted_ad_unit_ids;
        document.getElementById('targeted_ad_unit_ids').value = adUnitIds.join(',');

        // Fetch TREE data (not flat list) to get hierarchical structure with children
        // This is critical for size extraction from child ad units
        fetch(`{{ url_for('inventory.get_inventory_tree', tenant_id=tenant_id) }}`, { credentials: 'same-origin' })
            .then(response => response.json())
            .then(data => {
                console.log('[DEBUG] Tree API returned', data.root_units ? data.root_units.length : 0, 'root units');
                console.log('[DEBUG] Looking for ad unit IDs:', adUnitIds);

                if (data.root_units) {
                    // Process tree to cache all units with their children
                    const cacheTreeUnits = (units) => {
                        units.forEach(unit => {
                            inventoryCache.adUnits.set(unit.id, {
                                id: unit.id,
                                name: unit.name,
                                path: unit.path,
                                metadata: { sizes: unit.sizes || [] },
                                children: unit.children || []
                            });
                            if (unit.children && unit.children.length > 0) {
                                cacheTreeUnits(unit.children);
                            }
                        });
                    };
                    cacheTreeUnits(data.root_units);

                    const names = config.targeted_ad_unit_ids.map(id => {
                        const item = inventoryCache.adUnits.get(id);
                        console.log(`[DEBUG] Looking for ID "${id}": ${item ? `FOUND name="${item.name}"` : 'NOT FOUND'}`);

                        return item ? item.name : id;
                    });
                    updateSelectedDisplay('selected-ad-units', names, adUnitIds);
                    console.log('Populated ad units:', names);

                    // Extract sizes and show formats (same as when applying selection)
                    extractSizesFromInventory();
                }
            })
            .catch(error => {
                console.error('Failed to fetch ad unit tree:', error);
                // Fallback to IDs
                updateSelectedDisplay('selected-ad-units', adUnitIds, adUnitIds);
            });
    }

    if (config.targeted_placement_ids && config.targeted_placement_ids.length > 0) {
        // Handle both string and array formats
        let placementIds = config.targeted_placement_ids;
        if (typeof placementIds === 'string') {
            console.log('[DEBUG] targeted_placement_ids is a STRING, converting to array');
            placementIds = placementIds.split(',').map(id => id.trim()).filter(Boolean);
        }
        const placementIdsValue = Array.isArray(placementIds) ? placementIds.join(',') : placementIds;
        console.log('[DEBUG] Setting targeted_placement_ids hidden field:', placementIdsValue);
        console.log('[DEBUG] config.targeted_placement_ids array:', placementIds);
        document.getElementById('targeted_placement_ids').value = placementIdsValue;

        // Fetch specific placement names by ID (bypasses 500-item limit)
        const placementIdsParam = placementIds.join(',');
        fetch(`{{ url_for('inventory.get_inventory_list', tenant_id=tenant_id) }}?type=placement&ids=${encodeURIComponent(placementIdsParam)}`, { credentials: 'same-origin' })
            .then(response => response.json())
            .then(data => {
                if (data.items) {
                    console.log('[DEBUG] Placement API returned', data.items.length, 'items');
                    console.log('[DEBUG] Looking for placement IDs:', placementIds);
                    console.log('[DEBUG] Sample API item IDs:', data.items.slice(0, 5).map(i => i.id));

                    // Cache placement data in inventoryCache for size extraction
                    data.items.forEach(item => {
                        inventoryCache.placements.set(item.id, item);
                    });

                    const names = placementIds.map(id => {
                        const item = data.items.find(i => i.id === id);
                        console.log(`[DEBUG] Looking for ID "${id}": ${item ? `FOUND name="${item.name}"` : 'NOT FOUND'}`);
                        return item ? item.name : id;
                    });
                    updateSelectedDisplay('selected-placements', names, placementIds);
                    console.log('Populated placements:', names);
                    console.log('Populated placement IDs:', placementIds);

                    // Extract sizes and show formats (same as when applying selection)
                    extractSizesFromInventory();
                }
            })
            .catch(error => {
                console.error('Failed to fetch placement names:', error);
                // Fallback to IDs
                updateSelectedDisplay('selected-placements', placementIds, placementIds);
            });
    }

    // Set include descendants checkbox
    if (config.include_descendants) {
        const checkbox = document.querySelector('input[name="include_descendants"]');
        if (checkbox) checkbox.checked = true;
    }

    // Set creative formats
    if (product.formats && product.formats.length > 0) {
        console.log('[DEBUG] Product formats:', product.formats);
        product.formats.forEach((format, index) => {
            // Handle both FormatReference objects and legacy string format
            let formatId, agentUrl;
            if (typeof format === 'object') {
                formatId = format.format_id || format.id;
                agentUrl = format.agent_url;
                if (index === 0) {
                    console.log('[DEBUG] First format object:', format);
                    console.log('[DEBUG] Extracted formatId:', formatId, 'agentUrl:', agentUrl);
                }
            } else {
                formatId = format;
                agentUrl = 'https://creative.adcontextprotocol.org'; // default
            }

            // Try to match against pipe-delimited format first (current format)
            let checkbox = agentUrl ? document.querySelector(`.format-checkbox[value="${agentUrl}|${formatId}"]`) : null;

            // Fallback: try to match by data-format-id attribute
            if (!checkbox) {
                checkbox = document.querySelector(`.format-checkbox[data-format-id="${formatId}"]`);
            }

            if (checkbox) {
                checkbox.checked = true;
                console.log('Checked format:', formatId);
            } else {
                console.warn('Format checkbox not found for:', formatId, '(format object:', format, ')');
            }
        });
    }
})();
</script>
{% endif %}
<script>

// Initialize pricing options on page load
{% if product %}
// Edit mode: Load existing pricing options
const existingOptions = {{ product.pricing_options | tojson if product.pricing_options else '[]' }};
if (existingOptions.length > 0) {
    existingOptions.forEach((option, idx) => {
        addPricingOption(option);
    });
} else {
    // No existing options, add one empty option
    addPricingOption();
}
{% elif form_data %}
// Validation error: Restore pricing options from form data
(function() {
    // Extract pricing options from flat form_data keys
    const formData = {{ form_data | tojson }};
    const indices = new Set();

    // Find all pricing option indices from form data
    for (const key of Object.keys(formData)) {
        const match = key.match(/^pricing_model_(\d+)$/);
        if (match) {
            indices.add(parseInt(match[1]));
        }
    }

    if (indices.size > 0) {
        // Sort indices to add in order
        const sortedIndices = Array.from(indices).sort((a, b) => a - b);
        sortedIndices.forEach(idx => {
            const pricingModel = formData[`pricing_model_${idx}`] || '';
            const currency = formData[`currency_${idx}`] || 'USD';
            const rate = formData[`rate_${idx}`] || '';
            const floor = formData[`floor_${idx}`] || '';
            const minSpend = formData[`min_spend_${idx}`] || '';

            // Convert form data format to existingData format expected by addPricingOption
            let existingData = {
                currency: currency,
                rate: rate || null,
                min_spend_per_package: minSpend || null,
                price_guidance: floor ? { floor: floor } : null
            };

            // Map pricing model value to expected format
            if (pricingModel === 'cpm_fixed') {
                existingData.pricing_model = 'cpm';
                existingData.is_fixed = true;
            } else if (pricingModel === 'cpm_auction') {
                existingData.pricing_model = 'cpm';
                existingData.is_fixed = false;
            } else if (pricingModel === 'flat_rate') {
                existingData.pricing_model = 'flat_rate';
            } else if (pricingModel === 'vcpm') {
                existingData.pricing_model = 'vcpm';
            } else if (pricingModel === 'cpc') {
                existingData.pricing_model = 'cpc';
            }

            addPricingOption(existingData);
        });
    } else {
        // No pricing data found, add one empty option
        addPricingOption();
    }
})();
{% else %}
// Create mode: Add one empty option
addPricingOption();
{% endif %}

// Initialize format template picker
// Use window.formatPicker for global access (needed for form submission and testing)
(function() {
    // Get existing formats from product (edit mode) or form_data (validation error)
    const existingFormats = {% if product and product.formats %}{{ product.formats | tojson }}{% elif form_data and form_data.formats %}{{ form_data.formats | tojson }}{% else %}[]{% endif %};

    window.formatPicker = new FormatTemplatePicker({
        containerId: 'format-template-picker-container',
        hiddenInputId: 'formats-data',
        tenantId: '{{ tenant_id }}',
        adapterType: 'gam',  // GAM adapter - hides audio formats
        scriptRoot: '{{ request.script_root }}' || '',
        initialFormats: existingFormats,
        onSelectionChange: function(formats) {
            console.log('Formats updated:', formats.length, 'formats selected');
        }
    });

    // Integration with inventory picker: auto-populate sizes from selected inventory
    // Hook into inventory selection callbacks to extract sizes
    window.formatPickerIntegration = {
        addSizesFromInventory: function(sizes) {
            if (formatPicker && sizes && sizes.length > 0) {
                formatPicker.addSizesFromInventory(sizes);
            }
        },
        clearInventorySizes: function() {
            if (formatPicker) {
                formatPicker.clearInventorySizes();
            }
        }
    };
})();

// Format info modal functionality
function showFormatInfo(name, description, previewUrl, agentUrl, formatId) {
    const modal = document.getElementById('format-info-modal');
    document.getElementById('format-info-name').textContent = name;
    document.getElementById('format-info-description').textContent = description;

    // Handle preview image
    const previewContainer = document.getElementById('format-preview-container');
    const previewImg = document.getElementById('format-preview-img');
    const noPreview = document.getElementById('format-no-preview');

    if (previewUrl) {
        previewImg.src = previewUrl;
        previewImg.style.display = 'block';
        noPreview.style.display = 'none';
    } else {
        previewImg.style.display = 'none';
        noPreview.style.display = 'block';
    }

    // Handle more info link
    const moreInfoLink = document.getElementById('format-more-info-link');
    if (agentUrl && formatId) {
        // Construct URL to format details on agent (most agents follow this pattern)
        const detailsUrl = `${agentUrl}/formats/${formatId}`;
        moreInfoLink.href = detailsUrl;
        moreInfoLink.style.display = 'inline-block';
    } else {
        moreInfoLink.style.display = 'none';
    }

    modal.style.display = 'block';
}

function closeFormatInfo() {
    document.getElementById('format-info-modal').style.display = 'none';
}

// Close modal when clicking outside
window.onclick = function(event) {
    const modal = document.getElementById('format-info-modal');
    if (event.target == modal) {
        modal.style.display = 'none';
    }
}

// ============================================================================
// Creative Format Size Filtering Functions
// ============================================================================
// Note: All size filtering functions are defined earlier (before DOMContentLoaded)
// to ensure they're available when inventory picker callbacks fire.

/**
 * Select all visible formats
 */
function selectAllFormats() {
    const formatCards = document.querySelectorAll('.format-card');
    let selectedCount = 0;

    formatCards.forEach(card => {
        // Skip hidden cards
        if (card.style.display === 'none') return;

        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox && !checkbox.checked) {
            checkbox.checked = true;
            selectedCount++;
        }
    });

    // Update the summary
    updateFormatSummary();

    if (selectedCount > 0) {
        showToast(`Selected ${selectedCount} ${selectedCount === 1 ? 'format' : 'formats'}`, 'success');
    }
}

/**
 * Deselect all formats
 */
function deselectAllFormats() {
    const formatCards = document.querySelectorAll('.format-card');
    let deselectedCount = 0;

    formatCards.forEach(card => {
        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox && checkbox.checked) {
            checkbox.checked = false;
            deselectedCount++;
        }
    });

    // Update the summary
    updateFormatSummary();

    if (deselectedCount > 0) {
        showToast(`Deselected ${deselectedCount} ${deselectedCount === 1 ? 'format' : 'formats'}`, 'info');
    }
}

/**
 * Select all formats that match inventory sizes
 */
function selectAllMatchingFormats() {
    const matchingCards = document.querySelectorAll('.format-card.matches-inventory');
    let selectedCount = 0;

    matchingCards.forEach(card => {
        const checkbox = card.querySelector('input[type="checkbox"]');
        if (checkbox && !checkbox.checked) {
            checkbox.checked = true;
            selectedCount++;
        }
    });

    // Show feedback
    if (selectedCount > 0) {
        showToast(`Selected ${selectedCount} matching ${selectedCount === 1 ? 'format' : 'formats'}`, 'success');
    }

    // Update summary
    updateFormatSummary();
}

/**
 * Toggle show only matching formats
 */
function toggleShowOnlyMatching() {
    const toggle = document.getElementById('show-only-matching-toggle');
    const showOnlyMatching = toggle.checked;

    const formatCards = document.querySelectorAll('.format-card');

    formatCards.forEach(card => {
        if (showOnlyMatching) {
            // Hide non-matching cards
            if (!card.classList.contains('matches-inventory')) {
                card.style.display = 'none';
            } else {
                card.style.display = '';
            }
        } else {
            // Show all cards
            card.style.display = '';
        }
    });
}

/**
 * Show a toast notification
 */
function showToast(message, type = 'info') {
    // Simple toast implementation
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: ${type === 'success' ? '#28a745' : '#007bff'};
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 4px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

</script>

<!-- Format Info Modal -->
<div id="format-info-modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
    <div style="background-color: #fefefe; margin: 5% auto; padding: 2rem; border: 1px solid #888; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
            <h2 style="margin: 0; color: #333; font-size: 1.5rem;" id="format-info-name"></h2>
            <span onclick="closeFormatInfo()" style="color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1;">&times;</span>
        </div>

        <!-- Preview Image -->
        <div id="format-preview-container" style="margin-bottom: 1.5rem; text-align: center; background: #f8f9fa; border-radius: 4px; padding: 1rem; min-height: 200px; display: flex; align-items: center; justify-content: center;">
            <img id="format-preview-img" src="" alt="Format preview" style="max-width: 100%; max-height: 300px; border-radius: 4px; display: none;">
            <div id="format-no-preview" style="color: #999; display: none;">
                <div style="font-size: 3rem; margin-bottom: 0.5rem;">üñºÔ∏è</div>
                <div>No preview available</div>
            </div>
        </div>

        <!-- Description -->
        <div style="margin-bottom: 1.5rem;">
            <p id="format-info-description" style="color: #666; line-height: 1.6; margin: 0;"></p>
        </div>

        <!-- Actions -->
        <div style="display: flex; gap: 0.5rem;">
            <a id="format-more-info-link" href="#" target="_blank" class="btn btn-secondary" style="flex: 1; text-align: center; text-decoration: none; display: none;">
                Learn More ‚Üí
            </a>
            <button onclick="closeFormatInfo()" class="btn btn-primary" style="flex: 1;">Close</button>
        </div>
    </div>
</div>

<style>
/* Size chips styling */
.size-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.5rem 0.75rem;
    background: white;
    border: 2px solid #2196f3;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9rem;
}

.size-chip:hover {
    background: #e3f2fd;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.size-chip .size-label {
    font-weight: 600;
    color: #1976d2;
}

.size-chip .unit-count {
    color: #666;
    font-size: 0.85rem;
}

/* Format card match indicator - subtle background only */
.format-card.matches-inventory {
    background: #f0f7ff !important;
}

/* Toast notification */
.toast-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 1rem 1.5rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 10000;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    animation: slideIn 0.3s ease;
}

.toast-notification.success {
    border-left: 4px solid #4caf50;
}

.toast-notification.error {
    border-left: 4px solid #f44336;
}

.toast-notification.info {
    border-left: 4px solid #2196f3;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

.toast-notification.hiding {
    animation: slideOut 0.3s ease forwards;
}
</style>

{% endblock %}
